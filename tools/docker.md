# Docker

* [Docker Image and Docker Container](./docker.md#docker-image-and-docker-container)
* [Docker Containers and Virtual Machines](./docker.md#docker-containers-and-virtual-machines)
* [How to Create a Docker Image](./docker.md#how-to-create-a-docker-image)
  * [Interactive Method](./docker.md#interactive-method)
  * [Dockerfile Method](./docker.md#dockerfile-method)
* [Tips](./docker.md#tips)

## Docker Image and Docker Container

A `Docker image` is a read-only template that contains the source code, libraries, dependencies, tools, and other files for creating `a container` that can run on the `Docker platform`.

Since images are, in a way, just templates, you cannot start or run them. What you can do is use that template as a base to build a container. A container is, ultimately, just a running image.

The command for creating an image from a Dockerfile is __docker build__.

<img src="fig/container-layers.png">

A `Docker container` is a virtualized run-time environment where users can isolate applications from the underlying system. 

To create a container layer from an image, use the command __docker create__.

You can create multiple containers from the same docker image.

<img src="fig/Cx1eo.png">

### Show the docker images
```
docker images
```

### Show the running docker containers
```
docker ps
```
You can see all containers with

```
docker ps -a
```

## Docker Containers and Virtual Machines

<img src="fig/container-vs-virtual-machine.png">

<img src="fig/Docker-vs-VM-Memory-usage.webp">

## How to Create a Docker Image

### Interactive Method

__Advantages__: Quickest and simplest way to create Docker images. 

__Disadvantages__: Requiring error-prone manual reconfiguration of live interactive processes. 

The following is a set of simplified steps to creating an image interactively:

- Install Docker and launch the Docker engine.
- Open a terminal session.
- Use the following __Docker run__ command to start an interactive shell session with a container launched from the image specified by __image_name:tag_name__:
    ``` 
    docker run -it image_name:tag_name bash
    ```

    If you omit the tag name, then Docker automatically pulls the most recent image version, which is identified by the latest tag. If Docker cannot find the image locally then it will pull what it needs to build the container from the appropriate repository on Docker Hub.

    In our example, we’ll launch a container environment based on the latest version of Ubuntu:

    ```
    docker run -it ubuntu bash
    ```

- Now configure your container environment by, for example, installing all the frameworks, dependencies, libraries, updates, and application code you need. The following simple example adds an NGINX server:
    ```
    apt-get update && apt-get install -y nginx
    ```

    Next, you’ll need to know the name or ID of your running container instance.

- Open another Bash shell and type the following docker ps command to list active container processes:
    ```
    docker ps    
    ```

    ```
    CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES
    b20edbad48a6   ubuntu    "bash"    3 minutes ago   Up 3 minutes             vigorous_almeida
    ```
    This container name is randomly generated by the Docker daemon. But you can also identify your container with something more meaningful by assigning your own name using the __– name operator__ in the __Docker run__ command.

- Save your image using the __Docker commit__ command, specifying either the ID or name of the container from you which want to create it:
    ```
    docker commit vigorous_almeida ubuntu_testbed
    ```

    In the example above, we supplied the name of our container and called the resulting image __ubuntu_testbed__.

- Now, use the __Docker images__ command to see the image you’ve just created:
    ```
    docker images
    ```

- Finally, return to your interactive container shell and type exit to shut it down.
    ```
    exit
    ```

### Dockerfile Method

__Advantages__: Clean, compact and repeatable recipe-based images. Easier lifecycle management and easier integration into continuous integration (CI) and continuous delivery (CD) processes. 

The Dockerfile approach is the method of choice for real-world, enterprise-grade container deployments. It’s a more systematic, flexible, and efficient way to build Docker images and the key to compact, reliable, and secure container environments.

<img src="fig/image1.jpg">

In short, the Dockerfile method is a three-step process whereby you create the Dockerfile and add the commands you need to assemble the image.

[Example Dockerfile](./Dockerfile)
```
# Use the official Ubuntu 18.04 as base
FROM ubuntu:18.04
# Install nginx and curl
RUN apt-get update && apt-get upgrade -y && apt-get install -y nginx curl && rm -rf /var/lib/apt/lists/*
```

Now use the Docker build command to create your Docker image. Use the -t flag to set an image name and tag:
```
docker build -f Dockerfile -t my-nginx:0.1 .
```

## Visual Studio Code remote connect to a docker container

- Install SSH inside the container
  ```
  apt-get install openssh-server
  ```

- Enable the ssh service
  ```
  sudo systemctl enable ssh
  ```

- Enable root login in the container

  By default, ssh disables root login: you are expected to log in as user and then use su or sudo to become root.

  That said, if you want to disable this behaviour, edit `/etc/ssh/sshd_config` and add the line `PermitRootLogin Yes`.

  ```
  vim /etc/ssh/sshd_config
  ```

  ```
  # PermitRootLogin prohibit-password
  PermitRootLogin yes
  RSAAuthentication yes
  PubkeyAuthentication yes
  ```

- Set password for root user in the container
  ```
  passwd
  ```

- Start SSH server
  ```
  /etc/init.d/ssh restart
  ```  

- Publish port `22` as __8022__ or something similar, while starting the container
  ```
  docker run -p 8022:22 --name CONTIANER-NAME -it DOCKER-IMAGE
  ```

- Visual Studio Code Remote Host Config

  ```
  Host NAME-EASY-TO-IDENTIFY
      HostName 10.1.70.71
      User root
      Port 8022
  ```    

## Tips

### Show all docker images
```
docker images
```

### Show all docker containers

- Show active containers
  ```
  docker ps
  ```
- Show all containers
  ```
  docker ps -a
  ```

### Force stopping a container
```
docker kill CONTAINER-ID
```

### Interactive bash shell

The `-it` instructs Docker to allocate a __pseudo-TTY__ connected to the container's stdin; creating an interactive bash shell in the container.

```
docker run -it DOCKER-IMAGE
```

### Enable GPUs
As Docker doesn’t provide your system’s GPUs by default, you need to create containers with the `--gpus` flag for your hardware to show up. You can either specify specific devices to enable or use the `all` keyword.

```
docker run --gpus all -it DOCKER-IMAGE
```
Show GPU status
```
nvidia-smi
```


### Detached mode

You can start a docker container in detached mode with a `-d` option. So the container starts up and run in background. That means, you start up the container and could use the console after startup for other commands.

```
docker run -d -it DOCKER-IMAGE
```

### Give names to containers

You can give names to your containers using the `--name` flag for docker run.

If `--name` is not provided Docker will automatically generate an alphanumeric string for the container name.

```
docker run --name CONTAINER-NAME -it DOCKER-IMAGE
```

### Published ports
By default, when you create or run a container using docker create or docker run, it does not publish any of its ports to the outside world. To make a port available to services outside of Docker, use the `--publish` or `-p` flag. This creates a firewall rule which maps a container port to a port on the Docker host to the outside world. 

```
docker run -p 8022:22 --name CONTIANER-NAME -it DOCKER-IMAGE
```

### Remove a docker container

```
docker rm CONTAINER-NAME
dokcer rm -f CONTAINER-NAME
```

### Remove a docker image

```
docker image rm DOCKER-IMAGE
docker image rm -f DOCKER-IMAGE
```

### configure docker proxy
You can set the proxy environment variables when starting the container, for example:

```
docker run \
  -e http_proxy=http://username:password@proxy2.domain.com \
  -e https_proxy=http://username:password@proxy2.domain.com \
  DOCKER-IMAGE
```